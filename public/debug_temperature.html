<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Debug Temperature Mapping</title>
  <style>
    body {
      margin: 0;
      font-family: Arial, sans-serif;
      overflow: hidden;
      background: #000;
      color: #fff;
    }
    #canvas-container {
      width: 100vw;
      height: 100vh;
    }
    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
      font-size: 12px;
    }
    #controls {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(0,0,0,0.8);
      padding: 10px;
      border-radius: 5px;
    }
  </style>
</head>
<body>
  <div id="canvas-container"></div>
  <div id="info">
    <div>Mercury Position: <span id="mercury-pos">-</span></div>
    <div>Sun Direction: <span id="sun-dir">-</span></div>
    <div>Angle: <span id="angle">-</span></div>
    <div>FPS: <span id="fps">-</span></div>
  </div>
  <div id="controls">
    <button id="pause">Pause</button>
    <button id="reset">Reset</button>
    <br><br>
    <label><input type="checkbox" id="show-arrow" checked> Show Sun Arrow</label>
    <br>
    <label><input type="checkbox" id="show-axes" checked> Show Axes</label>
    <br>
    <label><input type="checkbox" id="auto-rotate"> Auto Rotate Mercury</label>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

  <script>
    // Debug version with simplified temperature shader
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x000011);

    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(20, 15, 20);

    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.getElementById('canvas-container').appendChild(renderer.domElement);

    const controls = new THREE.OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    // Lighting
    const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
    scene.add(ambientLight);

    // Sun
    const sunGeometry = new THREE.SphereGeometry(2, 32, 32);
    const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
    const sun = new THREE.Mesh(sunGeometry, sunMaterial);
    scene.add(sun);

    const sunLight = new THREE.PointLight(0xffffff, 2);
    scene.add(sunLight);

    // Mercury with debug shader
    const mercuryGeometry = new THREE.SphereGeometry(1.5, 64, 64);

    // Debug shader - simpler version
    const debugVertexShader = `
      varying vec3 vNormal;
      varying vec3 vWorldNormal;
      varying vec3 vPosition;

      void main() {
        vNormal = normal;
        vWorldNormal = normalize((modelMatrix * vec4(normal, 0.0)).xyz);
        vPosition = position;
        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
      }
    `;

    const debugFragmentShader = `
      uniform vec3 sunDirection;
      varying vec3 vNormal;
      varying vec3 vWorldNormal;
      varying vec3 vPosition;

      void main() {
        // Use LOCAL normal (not transformed)
        vec3 normal = normalize(vNormal);

        // Sun direction is passed in local space
        vec3 sunDir = normalize(sunDirection);

        // Calculate dot product
        float dotProduct = dot(normal, sunDir);

        // Simple coloring: red = facing sun, blue = facing away
        vec3 color;
        if (dotProduct > 0.0) {
          // Day side - interpolate from yellow to red
          color = mix(vec3(1.0, 1.0, 0.0), vec3(1.0, 0.0, 0.0), dotProduct);
        } else {
          // Night side - blue
          color = vec3(0.0, 0.0, 0.5 - dotProduct * 0.5);
        }

        // Add grid for reference
        float lon = atan(vPosition.z, vPosition.x);
        float lat = asin(vPosition.y / length(vPosition));
        float lonLines = abs(fract(degrees(lon) / 30.0) - 0.5);
        float latLines = abs(fract(degrees(lat) / 30.0) - 0.5);

        if (min(lonLines, latLines) < 0.05) {
          color = mix(vec3(0.0, 1.0, 0.0), color, 0.5);
        }

        gl_FragColor = vec4(color, 1.0);
      }
    `;

    const mercuryMaterial = new THREE.ShaderMaterial({
      uniforms: {
        sunDirection: { value: new THREE.Vector3(-1, 0, 0) }
      },
      vertexShader: debugVertexShader,
      fragmentShader: debugFragmentShader
    });

    const mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
    mercury.position.set(10, 0, 0);
    scene.add(mercury);

    // Add axes to Mercury
    const mercuryAxes = new THREE.AxesHelper(3);
    mercury.add(mercuryAxes);

    // Arrow showing sun direction
    const arrowHelper = new THREE.ArrowHelper(
      new THREE.Vector3(-1, 0, 0),
      mercury.position,
      5,
      0xffff00,
      1,
      1
    );
    scene.add(arrowHelper);

    // Orbit line
    const orbitPoints = [];
    for (let i = 0; i <= 100; i++) {
      const angle = (i / 100) * Math.PI * 2;
      orbitPoints.push(new THREE.Vector3(Math.cos(angle) * 10, 0, Math.sin(angle) * 10));
    }
    const orbitGeometry = new THREE.BufferGeometry().setFromPoints(orbitPoints);
    const orbitMaterial = new THREE.LineBasicMaterial({ color: 0x444466, opacity: 0.5, transparent: true });
    const orbitLine = new THREE.Line(orbitGeometry, orbitMaterial);
    scene.add(orbitLine);

    // Animation state
    let time = 0;
    let isPaused = false;
    let autoRotate = false;

    // Controls
    document.getElementById('pause').addEventListener('click', () => {
      isPaused = !isPaused;
      document.getElementById('pause').textContent = isPaused ? 'Play' : 'Pause';
    });

    document.getElementById('reset').addEventListener('click', () => {
      time = 0;
      mercury.position.set(10, 0, 0);
      mercury.rotation.set(0, 0, 0);
    });

    document.getElementById('show-arrow').addEventListener('change', (e) => {
      arrowHelper.visible = e.target.checked;
    });

    document.getElementById('show-axes').addEventListener('change', (e) => {
      mercuryAxes.visible = e.target.checked;
    });

    document.getElementById('auto-rotate').addEventListener('change', (e) => {
      autoRotate = e.target.checked;
    });

    // Animation loop
    let lastTime = performance.now();
    let frameCount = 0;
    let fpsTime = 0;

    function animate() {
      requestAnimationFrame(animate);

      const currentTime = performance.now();
      const deltaTime = currentTime - lastTime;
      lastTime = currentTime;

      // FPS calculation
      frameCount++;
      fpsTime += deltaTime;
      if (fpsTime >= 1000) {
        document.getElementById('fps').textContent = frameCount;
        frameCount = 0;
        fpsTime = 0;
      }

      if (!isPaused) {
        time += deltaTime * 0.0001;

        // Update Mercury position
        const angle = time * 2;
        mercury.position.x = Math.cos(angle) * 10;
        mercury.position.z = Math.sin(angle) * 10;

        // Auto-rotate Mercury if enabled
        if (autoRotate) {
          mercury.rotation.y = time * 3;
        }

        // Calculate sun direction from Mercury to Sun
        const sunPos = new THREE.Vector3(0, 0, 0);
        const mercuryPos = mercury.position.clone();
        const toSun = sunPos.sub(mercuryPos).normalize();

        // Transform to Mercury's local space
        // This is the critical part!
        mercury.updateMatrixWorld();
        const mercuryMatrixInverse = new THREE.Matrix4().copy(mercury.matrixWorld).invert();
        const sunDirLocal = toSun.clone().applyMatrix4(mercuryMatrixInverse).normalize();

        // Update shader uniform
        mercuryMaterial.uniforms.sunDirection.value.copy(sunDirLocal);

        // Update arrow
        arrowHelper.position.copy(mercury.position);
        arrowHelper.setDirection(toSun);

        // Update info
        document.getElementById('mercury-pos').textContent =
          `(${mercury.position.x.toFixed(1)}, ${mercury.position.y.toFixed(1)}, ${mercury.position.z.toFixed(1)})`;
        document.getElementById('sun-dir').textContent =
          `(${sunDirLocal.x.toFixed(2)}, ${sunDirLocal.y.toFixed(2)}, ${sunDirLocal.z.toFixed(2)})`;
        document.getElementById('angle').textContent =
          `${(angle * 180 / Math.PI).toFixed(1)}Â°`;
      }

      controls.update();
      renderer.render(scene, camera);
    }

    animate();

    // Handle resize
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>