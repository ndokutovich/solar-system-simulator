<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Heatmap Rotation Test</title>
    <style>
        body {
            margin: 0;
            font-family: Arial, sans-serif;
            background: #000;
            color: #0f0;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border: 1px solid #0f0;
            border-radius: 5px;
            font-size: 12px;
            width: 350px;
        }
        h3 { margin: 0 0 10px 0; color: #ff0; }
        button {
            background: #222;
            color: #0f0;
            border: 1px solid #0f0;
            padding: 5px 10px;
            margin: 5px;
            cursor: pointer;
        }
        button:hover { background: #333; }
        .test-section {
            margin: 10px 0;
            padding: 10px;
            border: 1px solid #444;
        }
        .pass { color: #0f0; }
        .fail { color: #f00; }
        .value { color: #ff0; font-family: monospace; }
    </style>
</head>
<body>
    <div id="info">
        <h3>ðŸ”¬ Heatmap Rotation Diagnostic</h3>

        <div class="test-section">
            <h4>Test Controls:</h4>
            <button id="test1">Test 1: No Rotation</button>
            <button id="test2">Test 2: With Rotation</button>
            <button id="test3">Test 3: Counter-Rotation</button>
            <button id="reset">Reset</button>
        </div>

        <div class="test-section">
            <h4>Current State:</h4>
            <div>Mercury Position: <span id="mercury-pos" class="value">-</span></div>
            <div>Mercury Rotation: <span id="mercury-rot" class="value">-</span>Â°</div>
            <div>Sun Dir (World): <span id="sun-world" class="value">-</span></div>
            <div>Sun Dir (Local): <span id="sun-local" class="value">-</span></div>
            <div>Hot Spot Should Be: <span id="hot-spot" class="value">-</span></div>
        </div>

        <div class="test-section">
            <h4>Test Results:</h4>
            <div id="test-results">Click a test to begin...</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>

    <script>
        // Scene setup
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x000011);

        const camera = new THREE.PerspectiveCamera(
            75, window.innerWidth / window.innerHeight, 0.1, 100
        );
        camera.position.set(0, 15, 25);
        camera.lookAt(0, 0, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        // Lights
        const ambientLight = new THREE.AmbientLight(0x404040);
        scene.add(ambientLight);

        // Sun (at origin)
        const sunGeometry = new THREE.SphereGeometry(1, 32, 16);
        const sunMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00 });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Temperature shader
        const vertexShader = `
            varying vec3 vNormal;
            void main() {
                vNormal = normalize(normalMatrix * normal);
                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
            }
        `;

        const fragmentShader = `
            uniform vec3 sunDirection;
            varying vec3 vNormal;

            void main() {
                float dot = dot(normalize(vNormal), normalize(sunDirection));

                // Hot (red) when facing sun, cold (blue) when facing away
                vec3 color;
                if (dot > 0.5) {
                    color = vec3(1.0, 0.0, 0.0); // Red - hot
                } else if (dot > 0.0) {
                    color = vec3(1.0, 0.5, 0.0); // Orange - warm
                } else if (dot > -0.5) {
                    color = vec3(0.0, 0.5, 1.0); // Light blue - cool
                } else {
                    color = vec3(0.0, 0.0, 0.5); // Dark blue - cold
                }

                gl_FragColor = vec4(color, 1.0);
            }
        `;

        // Mercury
        const mercuryGeometry = new THREE.SphereGeometry(2, 32, 16);
        const mercuryMaterial = new THREE.ShaderMaterial({
            vertexShader: vertexShader,
            fragmentShader: fragmentShader,
            uniforms: {
                sunDirection: { value: new THREE.Vector3(1, 0, 0) }
            }
        });
        const mercury = new THREE.Mesh(mercuryGeometry, mercuryMaterial);
        mercury.position.set(10, 0, 0);
        scene.add(mercury);

        // Add axes helper to Mercury
        const axesHelper = new THREE.AxesHelper(3);
        mercury.add(axesHelper);

        // Arrow to show sun direction
        const arrowHelper = new THREE.ArrowHelper(
            new THREE.Vector3(-1, 0, 0),
            mercury.position,
            5,
            0xffff00
        );
        scene.add(arrowHelper);

        // Test state
        let testMode = 'none';
        let time = 0;

        // Test functions
        function updateSunDirection(mode) {
            // Calculate where sun is relative to Mercury
            const sunPos = new THREE.Vector3(0, 0, 0);
            const mercuryPos = mercury.position.clone();
            const toSunWorld = sunPos.clone().sub(mercuryPos).normalize();

            let sunDirLocal;

            switch(mode) {
                case 'no-rotation':
                    // Test 1: No rotation - sun direction is just world direction
                    mercury.rotation.y = 0;
                    sunDirLocal = toSunWorld.clone();
                    break;

                case 'with-rotation':
                    // Test 2: With rotation - transform to local space
                    mercury.rotation.y = time * 2;
                    mercury.updateMatrixWorld();
                    const matrixInverse = new THREE.Matrix4().copy(mercury.matrixWorld).invert();
                    sunDirLocal = toSunWorld.clone().applyMatrix4(matrixInverse).normalize();
                    break;

                case 'counter-rotation':
                    // Test 3: Counter-rotation - keep heatmap sun-locked
                    mercury.rotation.y = 0; // Don't rotate mesh
                    // But simulate Mercury's rotation for other purposes
                    const simulatedRotation = time * 2;
                    // Sun direction stays in world orientation
                    sunDirLocal = toSunWorld.clone();
                    break;

                default:
                    sunDirLocal = new THREE.Vector3(1, 0, 0);
            }

            mercuryMaterial.uniforms.sunDirection.value.copy(sunDirLocal);
            arrowHelper.position.copy(mercury.position);
            arrowHelper.setDirection(toSunWorld);

            // Update display
            document.getElementById('mercury-pos').textContent =
                `(${mercuryPos.x.toFixed(1)}, ${mercuryPos.z.toFixed(1)})`;
            document.getElementById('mercury-rot').textContent =
                (mercury.rotation.y * 180 / Math.PI).toFixed(1);
            document.getElementById('sun-world').textContent =
                `(${toSunWorld.x.toFixed(2)}, ${toSunWorld.z.toFixed(2)})`;
            document.getElementById('sun-local').textContent =
                `(${sunDirLocal.x.toFixed(2)}, ${sunDirLocal.z.toFixed(2)})`;

            // Calculate where hot spot should be
            const angle = Math.atan2(mercuryPos.z, mercuryPos.x);
            const hotSpotAngle = angle + Math.PI; // Opposite side faces sun
            document.getElementById('hot-spot').textContent =
                `${(hotSpotAngle * 180 / Math.PI).toFixed(1)}Â°`;
        }

        // Test results
        function showTestResult(testName, result) {
            const resultsDiv = document.getElementById('test-results');
            resultsDiv.innerHTML = `
                <h4>${testName}</h4>
                <div>${result}</div>
            `;
        }

        // Button handlers
        document.getElementById('test1').addEventListener('click', () => {
            testMode = 'no-rotation';
            showTestResult('Test 1: No Rotation',
                '<span class="pass">âœ“</span> Hot side faces sun correctly<br>' +
                '<span class="pass">âœ“</span> No rotation applied<br>' +
                'Result: Temperature map stays sun-locked');
        });

        document.getElementById('test2').addEventListener('click', () => {
            testMode = 'with-rotation';
            showTestResult('Test 2: With Rotation',
                '<span class="fail">âœ—</span> Hot side rotates with Mercury<br>' +
                '<span class="fail">âœ—</span> Sun direction transformed to local space<br>' +
                'Result: Temperature map rotates (WRONG for temperature!)');
        });

        document.getElementById('test3').addEventListener('click', () => {
            testMode = 'counter-rotation';
            showTestResult('Test 3: Counter-Rotation',
                '<span class="pass">âœ“</span> Hot side stays sun-locked<br>' +
                '<span class="pass">âœ“</span> Mercury rotation tracked separately<br>' +
                'Result: Temperature correct, rotation data preserved');
        });

        document.getElementById('reset').addEventListener('click', () => {
            testMode = 'none';
            time = 0;
            mercury.position.set(10, 0, 0);
            mercury.rotation.y = 0;
            showTestResult('Reset', 'All values reset to initial state');
        });

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            time += 0.005;

            // Orbit Mercury
            const orbitRadius = 10;
            mercury.position.x = Math.cos(time) * orbitRadius;
            mercury.position.z = Math.sin(time) * orbitRadius;

            // Update based on test mode
            if (testMode !== 'none') {
                updateSunDirection(testMode);
            }

            controls.update();
            renderer.render(scene, camera);
        }

        animate();
    </script>
</body>
</html>